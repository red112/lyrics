<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>합창단 좌석 배치</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      display: flex;
      flex-wrap: wrap; /* 작은 화면에서 요소들이 줄바꿈되도록 */
      gap: 20px;
    }
    .left {
      flex: 1 1 60%; /* 유연하게 확장 및 축소 */
      min-width: 400px; /* 최소 너비 설정 */
    }
    .right {
      flex: 1 1 30%; /* 유연하게 확장 및 축소 */
      min-width: 250px; /* 최소 너비 설정 */
    }
    /* controls는 이제 part-buttons 옆에 위치하므로 margin-top 제거 */
    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap; /* 작은 화면에서 줄바꿈되도록 */
      flex-grow: 1; /* part-buttons 옆에서 남은 공간을 차지하도록 */
      justify-content: flex-end; /* 오른쪽으로 정렬 */
    }
    .controls label {
        white-space: nowrap; /* 줄 수: 텍스트 줄바꿈 방지 */
    }
    .controls input {
        width: 50px; /* 입력 필드 너비 조정 */
    }
    .grid-row-wrapper {
      display: flex;
      align-items: center; /* rowSummary가 셀과 같은 높이에 중앙 정렬 */
      margin-bottom: 4px; /* 각 줄 사이 간격 */
    }
    .grid {
      display: grid;
      gap: 4px;
      position: relative;
      user-select: none;
      flex-grow: 1; /* 그리드가 사용 가능한 공간을 채우도록 */
    }
    .cell {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #e5e7eb; /* gray */
      border: 1px solid #9ca3af;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      box-sizing: border-box; /* padding, border가 너비에 포함되도록 */
    }
    .cell.selected {
      outline: 3px solid #000;
      z-index: 10; /* 선택된 셀이 드래그 박스 위에 오도록 */
    }
    .part-and-controls-area { /* 파트 버튼과 컨트롤을 감싸는 새로운 div */
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 20px;
        align-items: center; /* 전체적으로 가운데 정렬 */
        width: 100%; /* 부모의 100% 너비 사용 */
    }
    .part-buttons {
      display: flex;
      flex-wrap: wrap; /* 버튼이 너무 많으면 줄바꿈 */
      gap: 10px;
      align-items: flex-start; /* 파트 인원 표시가 위로 정렬되도록 */
    }
    .part-buttons button {
      padding: 8px 12px;
      font-size: 14px;
      font-weight: bold;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      flex-direction: column; /* 텍스트와 숫자를 세로로 정렬 */
      align-items: center;
      min-width: 60px; /* 버튼 최소 너비 */
    }
    .part-count {
      font-size: 12px;
      margin-top: 2px;
      opacity: 0.8;
    }
    .btn-s { background: #ef4444; color: white; }
    .btn-a { background: #facc15; color: black; }
    .btn-t { background: #3b82f6; color: white; }
    .btn-b { background: #22c55e; color: white; }
    .btn-clear { background: #6b7280; color: white; } /* 해제 버튼 색상 */

    .selection-box {
      position: absolute;
      border: 2px dashed #000;
      background: rgba(0,0,0,0.1);
      pointer-events: none;
      z-index: 5; /* 셀보다 아래, 그리드 위에 */
    }
    .row-summary-inline {
      margin-left: 10px;
      font-size: 13px;
      padding: 4px 8px;
      background: #f3f4f6;
      border-radius: 6px;
      white-space: nowrap; /* 줄바꿈 방지 */
    }
    .total-summary {
      font-weight: bold;
      background: #e0e7ff;
      padding: 8px 12px;
      border-radius: 6px;
      display: flex;
      justify-content: center; /* 텍스트를 가운데 정렬 */
      align-items: center;
      /* flex-grow: 1; 이전에는 남은 공간을 차지했지만 이제는 크기 고정 */
      width: 120px; /* 적절한 고정 너비 설정 */
      flex-shrink: 0; /* 공간이 부족해도 줄어들지 않도록 */
    }
    .total-summary strong {
        font-size: 16px;
        margin-left: 5px; /* "총원:" 텍스트와의 간격 */
    }

    /* 기존 .right 섹션 제거에 따른 스타일 조정 */
    .right h3 {
        display: none; /* 필요 없으므로 숨김 */
    }
    #rowSummary, #totalSummary {
        display: none; /* 기존 요약 컨테이너 숨김 */
    }

    /* 모바일 반응형 */
    @media (max-width: 768px) {
        body {
            flex-direction: column;
        }
        .left, .right {
            min-width: unset;
            width: 100%;
        }
        .part-and-controls-area {
            flex-direction: column; /* 모바일에서 세로로 정렬 */
            align-items: center;
        }
        .part-buttons {
            justify-content: center;
            width: 100%; /* 버튼이 중앙에 오도록 */
        }
        .controls {
            justify-content: center; /* 컨트롤도 중앙 정렬 */
            width: 100%;
            margin-top: 10px; /* 간격 조정 */
        }
    }
  </style>
</head>
<body>
  <div class="left">
    <!-- 각 줄별로 래퍼를 추가하여 요약 정보를 옆에 붙일 수 있도록 합니다 -->
    <div id="grid-wrapper"></div>

    <!-- 파트 버튼과 컨트롤을 감싸는 새로운 컨테이너 -->
    <div class="part-and-controls-area">
        <div class="part-buttons">
          <button class="btn-s" data-part="S">S <span class="part-count" id="count-s">0</span></button>
          <button class="btn-a" data-part="A">A <span class="part-count" id="count-a">0</span></button>
          <button class="btn-t" data-part="T">T <span class="part-count" id="count-t">0</span></button>
          <button class="btn-b" data-part="B">B <span class="part-count" id="count-b">0</span></button>
          <!-- 해제 버튼 추가 -->
          <button class="btn-clear" data-part="X">X <span class="part-count" id="count-x">0</span></button>
        </div>

        <div class="total-summary">
            총원: <strong id="total-all-count">0</strong>명
        </div>

        <!-- 이전에 상단에 있던 controls div가 여기로 이동합니다 -->
        <div class="controls">
          <label>줄 수: <input type="number" id="rows" value="7" min="1"></label>
          <label>좌석 수: <input type="number" id="cols" value="16" min="1"></label>
          <button id="generate">생성</button>
        </div>
    </div>
  </div>

  <script>
    const gridWrapper = document.getElementById("grid-wrapper");
    const generateBtn = document.getElementById("generate");
    const partCountS = document.getElementById("count-s");
    const partCountA = document.getElementById("count-a");
    const partCountT = document.getElementById("count-t");
    const partCountB = document.getElementById("count-b");
    const partCountX = document.getElementById("count-x"); // X 버튼 카운트
    const totalAllCount = document.getElementById("total-all-count");

    const partColors = {
      S: "#ef4444", // red
      A: "#facc15", // yellow
      T: "#3b82f6", // blue
      B: "#22c55e", // green
      X: "#e5e7eb", // gray (초기 셀 색상과 동일)
    };

    let selectedCells = [];
    let isDragging = false;
    let startX, startY, selectionBox;
    let rows = 7, cols = 16;
    let gridElements = []; // 셀 요소를 저장할 배열

    function generateGrid(r, c) {
      rows = r;
      cols = c;
      gridWrapper.innerHTML = "";
      gridElements = []; // 초기화

      for (let row = 0; row < r; row++) {
        const rowWrapper = document.createElement("div");
        rowWrapper.className = "grid-row-wrapper";
        rowWrapper.dataset.row = row; // 줄 번호를 래퍼에도 추가

        const gridRow = document.createElement("div"); // 실제 셀들이 들어갈 그리드
        gridRow.className = "grid";
        gridRow.style.gridTemplateColumns = `repeat(${c}, 40px)`;
        rowWrapper.appendChild(gridRow);

        for (let col = 0; col < c; col++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.row = row;
          cell.dataset.col = col;
          // 초기 상태는 배치되지 않은 상태 (X)로 간주
          cell.dataset.part = "X";
          gridRow.appendChild(cell);
          gridElements.push(cell); // 배열에 셀 추가
        }

        const rowSummaryInline = document.createElement("div");
        rowSummaryInline.className = "row-summary-inline";
        rowSummaryInline.id = `row-summary-${row}`; // 각 줄별 고유 ID 부여
        rowWrapper.appendChild(rowSummaryInline);

        gridWrapper.appendChild(rowWrapper);
      }
      updateSummary();
    }

    function clearSelection() {
      selectedCells.forEach(cell => cell.classList.remove("selected"));
      selectedCells = [];
    }

    // 스크롤 오프셋을 고려한 클라이언트 좌표를 사용합니다.
    function getRelativeCoordinates(event) {
        if (event.touches) { // 터치 이벤트
            return { x: event.touches[0].clientX, y: event.touches[0].clientY };
        } else { // 마우스 이벤트
            return { x: event.clientX, y: event.clientY };
        }
    }

    function selectCellsInBox(x1, y1, x2, y2) {
      clearSelection();
      gridElements.forEach(cell => { // gridElements 배열 사용
        const rect = cell.getBoundingClientRect();
        if (
          rect.left < Math.max(x1, x2) &&
          rect.right > Math.min(x1, x2) &&
          rect.top < Math.max(y1, y2) &&
          rect.bottom > Math.min(y1, y2)
        ) {
          cell.classList.add("selected");
          selectedCells.push(cell);
        }
      });
    }

    function updateSummary() {
      let totalAll = 0;
      // X를 포함한 파트별 총계를 계산합니다.
      const partTotals = { S:0, A:0, T:0, B:0, X:0 };
      const totalGridCells = rows * cols; // 전체 격자 수

      for (let r = 0; r < rows; r++) {
        const rowCells = gridElements.filter(cell => parseInt(cell.dataset.row) === r);
        let total = 0;
        const partCountsInRow = { S:0, A:0, T:0, B:0, X:0 };

        rowCells.forEach(cell => {
          const part = cell.dataset.part;
          if (part) {
            if (part !== 'X') { // 'X' 파트는 총원에 포함하지 않습니다.
                total++;
            }
            partTotals[part]++;
            partCountsInRow[part]++;
          }
        });
        totalAll += total;

        const rowSummaryInline = document.getElementById(`row-summary-${r}`);
        if (rowSummaryInline) {
            if (total > 0) {
                const summaryParts = [];
                // X를 제외한 파트만 요약에 표시
                for (const partKey in partCountsInRow) {
                    if (partKey !== 'X' && partCountsInRow[partKey] > 0) {
                        summaryParts.push(`${partKey}:${partCountsInRow[partKey]}`);
                    }
                }
                rowSummaryInline.textContent = `총 ${total}명 | ${summaryParts.join(" ")}`;
            } else {
                rowSummaryInline.textContent = `배치 없음`;
            }
        }
      }

      // 전체 합계 및 파트별 인원 표시
      totalAllCount.textContent = totalAll;
      partCountS.textContent = partTotals.S;
      partCountA.textContent = partTotals.A;
      partCountT.textContent = partTotals.T;
      partCountB.textContent = partTotals.B;
      partCountX.textContent = partTotals.X; // 배치되지 않은 좌석 수 표시
    }

    // 터치/마우스 이벤트 시작
    function handleStart(e) {
      if (e.target.closest(".grid") || e.target.classList.contains("cell")) { // 셀 또는 그리드 배경 클릭 시
        isDragging = true;
        const coords = getRelativeCoordinates(e);
        startX = coords.x;
        startY = coords.y;
        selectionBox = document.createElement("div");
        selectionBox.className = "selection-box";
        document.body.appendChild(selectionBox);
        e.preventDefault(); // 기본 터치(스크롤 등) 동작 방지
      }
    }

    // 터치/마우스 이벤트 이동
    function handleMove(e) {
      if (isDragging && selectionBox) {
        const coords = getRelativeCoordinates(e);
        const x = Math.min(coords.x, startX);
        const y = Math.min(coords.y, startY);
        const w = Math.abs(coords.x - startX);
        const h = Math.abs(coords.y - startY);
        selectionBox.style.left = x + "px";
        selectionBox.style.top = y + "px";
        selectionBox.style.width = w + "px";
        selectionBox.style.height = h + "px";
        selectCellsInBox(startX, startY, coords.x, coords.y);
        e.preventDefault(); // 기본 터치(스크롤 등) 동작 방지
      }
    }

    // 터치/마우스 이벤트 종료
    function handleEnd() {
      if (isDragging) {
        isDragging = false;
        if (selectionBox) {
          selectionBox.remove();
          selectionBox = null;
        }
      }
    }


    document.addEventListener("mousedown", handleStart);
    document.addEventListener("mousemove", handleMove);
    document.addEventListener("mouseup", handleEnd);

    // 터치 이벤트 리스너 추가
    document.addEventListener("touchstart", handleStart, { passive: false });
    document.addEventListener("touchmove", handleMove, { passive: false });
    document.addEventListener("touchend", handleEnd);


    document.querySelectorAll(".part-buttons button").forEach((btn) => {
      btn.addEventListener("click", () => {
        const part = btn.dataset.part;
        if (part) applyPart(part);
      });
    });

    document.addEventListener("keydown", (e) => {
      const key = e.key.toUpperCase();
      if (["S","A","T","B"].includes(key)) {
        applyPart(key);
      } else if (e.key === "Delete" || e.key === "Backspace" || key === "X") { // X 키 추가
        selectedCells.forEach(cell => {
          cell.textContent = "";
          cell.style.background = partColors.X; // X 파트 색상 적용
          cell.dataset.part = "X"; // 파트를 'X'로 설정
        });
        updateSummary();
        clearSelection(); // 삭제 후 선택 해제
      }
    });

    function applyPart(part) {
      selectedCells.forEach(cell => {
        cell.textContent = (part === 'X' ? '' : part); // X일 때는 텍스트 표시 안함
        cell.style.background = partColors[part];
        cell.dataset.part = part;
      });
      updateSummary();
      clearSelection(); // 파트 적용 후 선택 해제
    }

    generateBtn.addEventListener("click", () => {
      const r = parseInt(document.getElementById("rows").value);
      const c = parseInt(document.getElementById("cols").value);
      generateGrid(r, c);
    });

    // 초기 생성 (7줄 16좌석)
    generateGrid(7, 16);
  </script>
</body>
</html>
